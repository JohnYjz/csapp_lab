/* 
考虑下界，取4位举例
1000 -8 为 min
0111 7 为max
要找到一个数
1000 + x = 0
1000 + 1000 = 0000 = 0;
 */

/* 
int x = random()
int y = random()

unsigned ux = (unsigned) x
unsigned uy = (unsigned) y

a (x < y) == (-x > -y)
int_min = -2147483648
-int_min = -2147483648
若x == int_min，y = 0;
则 -x = int_min, -y = 0，仍然有 -x < -y，所以不满足

b ((x + y) << 4) + y - x == 17 * y + 15 * x
x << 4 - x + y << 4 + y = x * 15 + y * 17
满足

c ~x + ~y + 1 == ~(x + y)
假设
x = 0001 = 1    ~x = 1110 = -2
y = 1000 = -8    ~y = 0111 = 7
~x + ~y + 1 = 5 + 1 = 6
x + y = -8 + 1 = -7 = 1001
~(x + y) = 0110 = 6

再假设
x = 1 = 0001    ~x = 1110 = -2
y = 2 = 0010    ~y = 1101 = -3

~x + ~y + 1 = -4
x + y = 3 = 0011
~(x + y) = 1100 = -4


数学原理：反码+1 = 补码
~x+1 = x;
~(x+y)+1 = (x+y) => ~(x+y) = x + y - 1 = ~x + ~y +2 -1 = ~x + ~y +1

d (ux - uy) == -(unsigned)(y - x)
位级运算没区别

e ((x >> 2) << 2) <= x
即 x / 4 * 4 <= x
其中 x >> 2 会发生最低位舍掉，x >> 2 << 2 的最后结果是最后两位清0 ，因此上式成立
*/